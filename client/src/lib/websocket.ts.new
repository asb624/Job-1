// WebSocket connection utility
let socket: WebSocket | null = null;
let reconnectAttempts = 0;
const maxReconnectAttempts = 5;
const reconnectDelay = 1000;

// Queue for messages when socket is not connected
const messageQueue: any[] = [];

// Setup socket event handlers
function setupSocketEventHandlers() {
  if (!socket) return;
  
  socket.onopen = () => {
    console.log('WebSocket connection established');
    reconnectAttempts = 0;
    
    // Send any queued messages
    while (messageQueue.length > 0) {
      const message = messageQueue.shift();
      if (message) {
        sendToWebsocket(message);
      }
    }
  };
  
  socket.onmessage = (event) => {
    try {
      const data = JSON.parse(event.data);
      
      // Dispatch a custom event that can be listened to elsewhere
      const customEvent = new CustomEvent('websocket-message', { detail: data });
      window.dispatchEvent(customEvent);
    } catch (error) {
      console.error('Error parsing WebSocket message:', error);
    }
  };
  
  socket.onclose = () => {
    console.log('WebSocket closed');
    
    // Attempt to reconnect if not at maximum attempts
    if (reconnectAttempts < maxReconnectAttempts) {
      reconnectAttempts++;
      console.log('WebSocket reconnecting from subscription...');
      
      setTimeout(() => {
        initializeWebSocket();
      }, reconnectDelay * reconnectAttempts);
    } else {
      console.error('Max reconnection attempts reached');
    }
  };
  
  socket.onerror = (error) => {
    console.error('WebSocket error:', error);
  };
}

// Connect to WebSocket with userId
export function connectWebSocket(userId: number): WebSocket {
  // Close existing connection if there is one
  if (socket && (socket.readyState === WebSocket.OPEN || socket.readyState === WebSocket.CONNECTING)) {
    socket.close();
  }
  
  // Determine WebSocket URL based on window location
  const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
  const wsUrl = `${protocol}//${window.location.host}/ws?userId=${userId}`;
  
  // Create new WebSocket connection
  socket = new WebSocket(wsUrl);
  
  // Set up event handlers
  setupSocketEventHandlers();
  
  return socket;
}

// Initialize WebSocket connection without userId
export function initializeWebSocket() {
  // Close existing connection if there is one
  if (socket && (socket.readyState === WebSocket.OPEN || socket.readyState === WebSocket.CONNECTING)) {
    socket.close();
  }
  
  // Determine WebSocket URL based on window location
  const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
  const wsUrl = `${protocol}//${window.location.host}/ws`;
  
  // Create new WebSocket connection
  socket = new WebSocket(wsUrl);
  
  // Set up event handlers
  setupSocketEventHandlers();
}

// Send a message through the WebSocket
export function sendToWebsocket(message: any) {
  if (!socket || socket.readyState !== WebSocket.OPEN) {
    // Queue the message if socket isn't open
    messageQueue.push(message);
    
    // Initialize WebSocket if not connected
    if (!socket || socket.readyState === WebSocket.CLOSED) {
      initializeWebSocket();
    }
    
    return;
  }
  
  // Send the message
  socket.send(JSON.stringify(message));
}

// Listen for specific message types
export function listenForWebSocketMessage<T = any>(
  messageType: string,
  callback: (data: T) => void
): () => void {
  const handler = (event: Event) => {
    const customEvent = event as CustomEvent;
    const data = customEvent.detail;
    
    if (data && data.type === messageType) {
      callback(data as T);
    }
  };
  
  window.addEventListener('websocket-message', handler);
  
  // Return a function to remove the listener
  return () => {
    window.removeEventListener('websocket-message', handler);
  };
}

// Specifically subscribe to message events with authentication
export function subscribeToMessages(
  callback: (data: any) => void,
  userId: number
): () => void {
  // Send authentication message when connected
  if (socket && socket.readyState === WebSocket.OPEN) {
    sendToWebsocket({
      type: 'auth',
      action: 'identify',
      payload: { userId }
    });
  }
  
  // Set up reconnect handler to re-authenticate
  const reconnectHandler = () => {
    if (socket && socket.readyState === WebSocket.OPEN) {
      sendToWebsocket({
        type: 'auth',
        action: 'identify',
        payload: { userId }
      });
    }
  };
  
  socket?.addEventListener('open', reconnectHandler);
  
  // Listen for message events
  const unsubscribe = listenForWebSocketMessage('message', callback);
  
  // Return function to clean up both listeners
  return () => {
    unsubscribe();
    socket?.removeEventListener('open', reconnectHandler);
  };
}

// Initialize WebSocket on page load
if (typeof window !== 'undefined') {
  initializeWebSocket();
  
  // Reconnect on visibilitychange (when user returns to tab)
  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible' && 
        (!socket || socket.readyState === WebSocket.CLOSED)) {
      initializeWebSocket();
    }
  });
}